import asyncio
import logging
from typing import TYPE_CHECKING, List, Dict, Any, Optional

if TYPE_CHECKING:
    from promptchain.utils.agent_chain import AgentChain

logger = logging.getLogger(__name__)

async def execute_static_plan_strategy_async(agent_chain_instance: 'AgentChain', initial_user_input: str) -> str:
    """Executes a plan of agents generated by the router."""
    if agent_chain_instance.verbose: print(f"\n--- Executing Router Strategy: static_plan ---")

    # 1. Get the plan from the router
    agent_chain_instance.logger.log_run({"event": "static_plan_get_plan_start"})
    decision_output: Optional[str] = None
    parsed_decision: Dict[str, Any] = {}
    try:
        if agent_chain_instance.custom_router_function:
            logging.warning("Custom router function used with 'static_plan' strategy. Ensure it returns {'plan': [...], 'initial_input': ...}")
            decision_output = await agent_chain_instance.custom_router_function(
                user_input=initial_user_input,
                history=agent_chain_instance._conversation_history,
                agent_descriptions=agent_chain_instance.agent_descriptions
            )
        elif agent_chain_instance.decision_maker_chain:
            decision_output = await agent_chain_instance.decision_maker_chain.process_prompt_async(initial_user_input)
        else:
            raise RuntimeError("No router configured for static_plan strategy.")

        if agent_chain_instance.verbose: print(f"  Router Plan Output: {decision_output}")
        parsed_decision = agent_chain_instance._parse_decision(decision_output)

        if not parsed_decision or "plan" not in parsed_decision or "initial_input" not in parsed_decision:
            error_msg = "Router failed to generate a valid plan for static_plan strategy."
            if agent_chain_instance.verbose: print(f"  Error: {error_msg} Router Output: {decision_output}")
            agent_chain_instance.logger.log_run({"event": "static_plan_invalid_plan", "raw_output": decision_output, "parsed": parsed_decision})
            return f"Error: Could not determine execution plan. Router output was: {decision_output or '[Empty]'}"

    except Exception as e:
        error_msg = f"Error getting plan from router: {e}"
        logging.error(error_msg, exc_info=True)
        agent_chain_instance.logger.log_run({"event": "static_plan_router_error", "error": str(e)})
        return f"Sorry, an error occurred while planning the execution: {e}"

    plan: List[str] = parsed_decision["plan"]
    current_input: str = parsed_decision["initial_input"]
    final_response: str = ""

    if agent_chain_instance.verbose: print(f"  Executing Plan: {' -> '.join(plan)}")
    agent_chain_instance.logger.log_run({"event": "static_plan_execution_start", "plan": plan, "initial_input_length": len(current_input)})

    for i, agent_name in enumerate(plan):
        step_num = i + 1
        if agent_chain_instance.verbose: print(f"  Plan Step {step_num}/{len(plan)}: Running agent '{agent_name}'")
        agent_chain_instance.logger.log_run({
            "event": "static_plan_step_start", "step": step_num, "agent": agent_name,
            "input_length": len(current_input)
        })

        if agent_name not in agent_chain_instance.agents:
            final_response = f"Error in plan: Agent '{agent_name}' not found."
            agent_chain_instance.logger.log_run({"event": "static_plan_step_error", "step": step_num, "agent": agent_name, "reason": "Agent not found"})
            break

        selected_agent = agent_chain_instance.agents[agent_name]
        agent_response_raw: str = ""
        agent_final_output: Optional[str] = None

        try:
            agent_input_for_this_run = current_input
            agent_loop_broken = False
            for agent_internal_step in range(agent_chain_instance.max_internal_steps):
                if agent_chain_instance.verbose: print(f"    Agent Internal Step {agent_internal_step + 1}/{agent_chain_instance.max_internal_steps} for '{agent_name}'")
                
                agent_response_raw = await selected_agent.process_prompt_async(agent_input_for_this_run)

                reroute_prefix = "[REROUTE]"
                final_prefix = "[FINAL]"
                response_stripped = agent_response_raw.strip()

                if response_stripped.startswith(reroute_prefix):
                    next_input_content = response_stripped[len(reroute_prefix):].strip()
                    if agent_chain_instance.verbose: print(f"    Agent '{agent_name}' requested internal reroute. Next internal input: {next_input_content[:100]}...")
                    agent_chain_instance.logger.log_run({"event": "static_plan_agent_reroute", "plan_step": step_num, "agent": agent_name, "internal_step": agent_internal_step + 1})
                    agent_input_for_this_run = next_input_content
                    continue
                elif response_stripped.startswith(final_prefix):
                    final_response = response_stripped[len(final_prefix):].strip()
                    if agent_chain_instance.verbose: print(f"    Agent '{agent_name}' provided [FINAL] answer. Ending plan execution.")
                    agent_chain_instance.logger.log_run({"event": "static_plan_agent_final_prefix", "plan_step": step_num, "agent": agent_name, "internal_step": agent_internal_step + 1})
                    agent_loop_broken = True
                    break
                else:
                    agent_final_output = agent_response_raw
                    if agent_chain_instance.verbose: print(f"    Agent '{agent_name}' finished its step (no prefix). Output length: {len(agent_final_output)}")
                    agent_chain_instance.logger.log_run({"event": "static_plan_agent_step_complete", "plan_step": step_num, "agent": agent_name, "internal_step": agent_internal_step + 1})
                    agent_loop_broken = True
                    break
            
            if not agent_loop_broken and agent_internal_step == agent_chain_instance.max_internal_steps - 1:
                logging.warning(f"Agent '{agent_name}' reached max internal steps ({agent_chain_instance.max_internal_steps}) during plan step {step_num}.")
                agent_chain_instance.logger.log_run({"event": "static_plan_agent_max_steps", "plan_step": step_num, "agent": agent_name})
                agent_final_output = agent_response_raw

            if final_response:
                break

            if agent_final_output is None:
                final_response = f"Error: Agent '{agent_name}' failed to produce an output in step {step_num}."
                agent_chain_instance.logger.log_run({"event": "static_plan_step_error", "step": step_num, "agent": agent_name, "reason": "No final output from agent"})
                break

            agent_chain_instance.logger.log_run({
                "event": "static_plan_step_success", "step": step_num, "agent": agent_name,
                "output_length": len(agent_final_output)
            })
            current_input = agent_final_output

        except Exception as e:
            error_msg = f"Error executing agent '{agent_name}' in plan step {step_num}: {e}"
            logging.error(error_msg, exc_info=True)
            agent_chain_instance.logger.log_run({"event": "static_plan_step_error", "step": step_num, "agent": agent_name, "error": str(e)})
            final_response = f"Plan failed at step {step_num} ({agent_name}): {e}"
            break
        
        if final_response:
            break
            
    if not final_response:
        final_response = current_input
        if not final_response:
            final_response = "[Static plan completed but produced an empty final response.]"
            agent_chain_instance.logger.log_run({"event": "static_plan_empty_response"})

    agent_chain_instance.logger.log_run({"event": "static_plan_execution_end", "final_response_length": len(final_response)})
    return final_response 